#ifndef SIMPLEMINIJAVACOMPILERTOC_STREAMER_H
#define SIMPLEMINIJAVACOMPILERTOC_STREAMER_H

#include "../../lexer/include/lexer.h"

/**
 * @class TokenStreamer
 * @brief A utility class for managing a sequence of tokens generated during lexical analysis.
 *
 * The TokenStreamer is responsible for providing a convenient interface for parsing tokens
 * from a java source code file. It supports common parsing operations like reading,
 * peeking, skipping, and navigating through tokens.
 *
 * It integrates tightly with the lexer, using its output (a vector of tokens) as input, and
 * exposes methods to advance through tokens, backtrack, and skip irrelevant tokens (e.g., whitespace or comments).
 */
class TokenStreamer {
private:
    /// A list of tokens that have been generated by the lexer.
    std::vector<Token> tokens;

    /// The current index being processed in the token list.
    int current = 0;

    /// Saved index position, used for restoring the current token pointer during backtracking.
    int saved;
public:

    /**
     * @brief Constructs a TokenStreamer for a given source code.
     * @param source The Mini-Java source code as a string.
     *
     * The constructor internally calls the `tokenize` function from the lexer
     * to generate tokens from the source code.
     */
    TokenStreamer(const std::string &source) :
            tokens(tokenize(source)) {}

    /**
     * @brief Determines if the current token is a whitespace, block comment, or line comment.
     * @return `true` if the token should be skipped, `false` otherwise.
     */
    bool shouldSkip() {
        return tokens[current].type == TokenType::WHITESPACE ||
               tokens[current].type == TokenType::BLOCK_COMMENT ||
               tokens[current].type == TokenType::LINE_COMMENT;
    }

    /**
     * @brief Reads the next valid token, skipping over irrelevant tokens (whitespace, comments).
     * @return A pointer to the next valid token, or `nullptr` if the end of the token stream is reached.
     *
     * This function advances the `current` pointer to the next token and returns it.
     */
    Token *read() {
        while (hasToken() && shouldSkip()) {
            current++;
        }
        if (!hasToken()) {
            return nullptr;
        }
        return &tokens[current++];
    }

    /**
     * @brief Peeks at the next valid token without advancing the token pointer.
     * @return A pointer to the next valid token, or `nullptr` if the end of the token stream is reached.
     *
     * Unlike `read`, this function does not modify the `current` pointer.
     */
    Token *peek() {
        while (hasToken() && shouldSkip()) {
            current++;
        }
        if (!hasToken()) {
            return nullptr;
        }
        return &tokens[current];
    }

    /**
     * @brief Reads tokens until a token with the specified lexeme is found.
     * @param lexeme The target lexeme to search for.
     * @return A pointer to the token with the specified lexeme, or `nullptr` if not found.
     *
     * This function continuously advances through the tokens using `read` until a matching token is found.
     */
    Token *readUntil(const std::string& lexeme) {
        while (hasToken()) {
            Token *token = read();
            if (token != nullptr && token->lexeme == lexeme) {
                return token;
            }
        }
        return nullptr;
    }

    /**
     * @brief Checks if there are more tokens available in the stream.
     * @return `true` if more tokens are available, `false` otherwise.
     */
    bool hasToken() {
        return current < tokens.size();
    }

    /**
     * @brief Moves the token pointer one step backward.
     *
     * This is useful for backtracking when parsing rules fail and needs to attempt another rule.
     */
    void unread() {
        current--;
    }

    /**
     * @brief Saves the current position of the token pointer.
     */
    void save() {
        saved = current;
    }

    /**
     * @brief Restores the token pointer to the last saved position.
     */
    void restore() {
        current = saved;
    }
};


#endif //SIMPLEMINIJAVACOMPILERTOC_STREAMER_H
